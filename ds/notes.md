- in pow(base, quotient) handle pow(0,0) properly
- in binary search evaluate fn goes from false->true return r else if true->false return l. make sure evaluate(l/r) agrees respectively
- in merge sort take care of left or right exhaust. Either append \inf to l/r or handle in conditionals
- Complexity notations
    - O notation is when we only have upper bound(0 lower bound), not necessarily tight
    - \Theta notation if when we have both lower and upper bound.
    - \Omega is when we only have lower bound
- monotically (increasing/decreasign) (</>)=, strictly </>
- heap property is parent<=child
- build heap needs heapify only till floor(n/2). its \theta(n) time
- heap sort -> swap root with last. logically reduce heap size to n-1. heapify on root
- topological sort: dfs on each node. prepend to list when all childs visited
- strongly connected components: 2 times dfs
    - dfs(G), note finish times. G to transpose(G).
    - dfs(transpose(G)) in order of decreasing finish times. emit each forest
- minimum spanning tree. prims alog: keep picking minimum edge ie. curretly reachable(priority queue)
- negative weights, non-dag shortest path. bellman ford: repeat |V|-1 times: for all E update node weights(only reachable from source works fine)
    - negative cycle. at end of above - no node should further reduce ie. w(u)+w(v,v) < w(v)
    - O(V*E) time
- dag with negative weights shortest path: dfs from source. tightening weights of nodes(O(E+V))
- Dijkstra: keep doing 1 level bfs repeatedly on minimum weight node. mark visited after bfs done
# todo:
- implement nth order select(ith median)
- study manacher's algo(low priority)
- how do we access node to its position in heap/pq?